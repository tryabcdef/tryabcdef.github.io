---
title: "Software Testing Terminologies"
excerpt: "Important terms and terminologies in Software Testing<br/>"
collection: testing-mindspace
---

* Testing:
The process of evaluating software to identify bugs, ensure functionality, and validate that it meets the requirements.

* Functional Testing:
Testing the application's features and functionality to ensure they work as intended based on requirements.

* Smoke Testing:
A preliminary test to check whether the core functionalities of a build work before proceeding with detailed testing.

* Sanity Testing:
A focused testing approach to verify that specific functionality or bug fixes are working correctly.

* Regression Testing:
Re-testing the application to ensure that recent changes have not introduced new defects in existing functionality.

* Integration Testing:
Testing the interaction between different modules or components of the application to ensure seamless integration.

* Monkey Testing:
Random testing performed without specific test cases to check for crashes or unexpected behavior.

* Gorilla Testing:
Intensive testing of a single module or feature to ensure robustness and stability.

* Automation Testing:
The process of using tools and scripts to execute test cases automatically, saving time and effort.

* Database Testing:
Testing the database for data integrity, schema validation, performance, and security.

* GUI Testing:
Testing the graphical user interface of an application to ensure elements like buttons, menus, and forms work as expected.

* System Testing:
Testing the entire application as a complete system to validate its compliance with specified requirements.

* ReTesting:
Testing specific test cases that previously failed to verify if the issue has been fixed.

* Adhoc Testing:
Informal testing conducted without a structured plan or test cases, focusing on finding bugs intuitively.

* Web Application Testing:
Testing web-based applications for functionality, compatibility, performance, and security.

* Mobile Application Testing:
Testing mobile apps for functionality, usability, compatibility, and performance on different devices and platforms.

* Interruption Testing:
Testing how an application handles interruptions, like incoming calls, notifications, or loss of network connectivity.

* UAT Testing (User Acceptance Testing):
Testing conducted by end-users to verify if the application meets business needs and is ready for release.

* API Testing:
Testing application programming interfaces (APIs) to ensure they perform as expected in terms of functionality, reliability, and security.

* Contract Testing:
Testing performed to verify that two services (e.g., APIs) can communicate and adhere to the agreed-upon contract.

* Maintenance Testing:
Testing performed after deployment to ensure updates or changes do not negatively impact the application.

* White Box Testing:
Testing the internal logic, structure, and code of the application, usually done by developers.

* Black Box Testing:
Testing the application without knowledge of its internal workings, focusing only on inputs and outputs.

* Grey Box Testing:
A hybrid approach combining elements of white box and black box testing, with partial knowledge of the application's internal structure.

* Verification:
The process of checking whether the product is being built correctly by validating design, specifications, and processes.

* Validation:
The process of checking whether the built product meets the user’s requirements and functions as intended.

* Test Environment Setup:
Preparing hardware, software, and configurations for executing test cases.

* Crowdsourced Testing:
Leveraging a crowd of external testers to evaluate the application on diverse setups.

* Accessibility Testing:
Ensuring the application is usable by people with disabilities (e.g., WCAG compliance).

* Installation Testing:
Verifying that the application installs and uninstalls correctly across platforms.

* Cross-Browser Testing:
Ensuring web applications work consistently across various browsers and browser versions.

* Cross-Platform Testing:
Validating software functionality across different operating systems and devices.

* Software Testing Life Cycle (STLC):
The phases involved in testing, from planning to closure.

* Defect Density:
A metric used to measure the number of defects per unit of code or test cases.

* Code Coverage:
Measuring the extent to which the codebase is executed during testing.

* Unit Testing:
Testing small pieces of the software (like a button or function) to make sure they work as expected.

* Acceptance Testing:
A final test to see if the software meets the user’s needs and is ready to be delivered.

* Alpha Testing:
Testing done by the internal team before the software is released to real users.

* Beta Testing:
Testing done by actual users to find bugs and give feedback before the final release.

* Exploratory Testing:
Testing without a plan—just exploring the app to find any unexpected issues.

* Boundary Value Testing:
Checking how the app behaves with edge or limit values, like the smallest or largest input.

* Equivalence Partitioning:
Grouping similar inputs together and testing one from each group instead of testing everything.

* Static Testing:
Reviewing documents, code, or designs without running the software.

* Dynamic Testing:
Running the software to check how it behaves and if it works properly.

* Performance Testing:
Checking how fast the app runs and whether it can handle a lot of users.
* Load Testing:
Testing how the app works when many people use it at the same time.

* Stress Testing:
Overloading the app to see when it breaks.

* Scalability Testing:
Testing if the app can grow to handle more users or data without problems.

* Security Testing:
Making sure the app is safe from hackers or unauthorized access.

* Penetration Testing:
Pretending to be a hacker to find security weaknesses in the app.

* Vulnerability Testing:
Scanning the app for any weak spots or potential risks.

* Compatibility Testing:
Ensuring the app works smoothly on different devices, browsers, or systems.

* End-to-End Testing:
Testing the app’s entire process, like how a user completes a task from start to finish.

* Mutation Testing:
Making small changes in the code to see if the tests can catch the errors.

* Risk-Based Testing:
Focusing on the riskiest areas of the app first to find critical issues.

* Recovery Testing:
Checking if the app recovers properly after crashes or failures.

* Parallel Testing:
Testing multiple parts of the app at the same time.

* A/B Testing:
Comparing two versions of a feature to see which one users like more.

* Test Planning:
Deciding what to test, how to test, and what tools to use.

* Test Case Design:
Writing step-by-step instructions to check if the app works as expected.

* Test Data Management:
Creating and managing fake data for testing purposes.

* Defect Life Cycle:
Tracking a bug’s journey from being found to being fixed.

* Agile Testing:
Testing in small, fast cycles during the development process.

* Continuous Testing:
Testing early and frequently as new features are added.

* Shift-Left Testing:
Testing earlier in the development process to catch problems sooner.

* Test Automation Frameworks:
Tools or systems used to automate repetitive testing tasks.

* Localization Testing:
Testing if the app works for a specific language, region, or culture.

* Globalization Testing:
Ensuring the app works across all languages and regions without issues.

* Wearable Device Testing:
Testing apps for devices like smartwatches or fitness trackers.

*  IoT Testing:
Checking apps for connected devices like smart home gadgets.

* Blockchain Testing:
Testing systems that use blockchain technology for security and data accuracy.

* Big Data Testing:
Making sure apps that handle huge amounts of data work correctly and efficiently.

* Decision Table Testing:
Testing how the app works with different combinations of inputs.

* Use Case Testing:
Testing the app based on how people will use it in real-life scenarios.

* Pairwise Testing:
Testing combinations of two inputs at a time to reduce effort while still covering the basics.

* Test Environment Setup:
Preparing everything needed to test, like devices, servers, or tools.

* Crowdsourced Testing:
Getting a group of outside testers to find bugs on different devices and setups.

* Accessibility Testing:
Ensuring the app is easy to use for people with disabilities.

* Installation Testing:
Checking if the app installs and uninstalls smoothly.

* Cross-Browser Testing:
Making sure the app works well on all browsers, like Chrome or Safari.

* Cross-Platform Testing:
Testing if the app runs on different operating systems like Windows, iOS, or Android.

* Software Testing Life Cycle (STLC):
The step-by-step process of testing, from planning to reporting.

* Defect Density:
Measuring how many bugs exist in a specific part of the software.

* Code Coverage:
Checking how much of the app’s code is tested to ensure good coverage.